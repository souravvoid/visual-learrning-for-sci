<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Interactive Lab — Elastic Collision (Physics-first)</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #071025;
            --panel: #0f172a;
            --muted: #94a3b8;
            --accent: #22d3ee;
            --accent2: #f87171;
        }

        * {
            box-sizing: border-box;
            font-family: Inter, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif
        }

        body {
            margin: 0;
            min-height: 100vh;
            background: linear-gradient(180deg, var(--bg), #02040a);
            color: #e6eef8;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 18px;
        }

        header {
            width: 95%;
            max-width: 1100px;
            margin-bottom: 12px
        }

        h1 {
            margin: 0;
            font-size: 20px;
            font-weight: 600
        }

        p.lead {
            margin: 6px 0 0;
            color: var(--muted);
            font-size: 13px
        }

        #container {
            width: 95%;
            max-width: 1100px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 14px;
            display: grid;
            grid-template-columns: 1fr 360px;
            gap: 14px;
            align-items: start;
        }

        /* lab stage */
        #lab {
            position: relative;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
            height: 320px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.03);
            padding: 10px;
        }

        #arena {
            position: relative;
            height: 100%;
            width: 100%;
            background:
                linear-gradient(180deg, rgba(255, 255, 255, 0.01), transparent 40%);
            border-radius: 6px;
            overflow: hidden;
        }

        .wall {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 6px;
            background: rgba(255, 255, 255, 0.06);
        }

        .wall.left {
            left: 0;
            border-top-left-radius: 6px;
            border-bottom-left-radius: 6px
        }

        .wall.right {
            right: 0;
            border-top-right-radius: 6px;
            border-bottom-right-radius: 6px
        }

        .ball {
            position: absolute;
            top: 50%;
            width: 80px;
            height: 80px;
            margin-top: -40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            will-change: transform;
            box-shadow: 0 4px 18px rgba(0, 0, 0, 0.6);
            transform: translateX(0px) translateY(-50%);
        }

        #ball1 {
            background: linear-gradient(135deg, var(--accent2), #ef4444)
        }

        #ball2 {
            background: linear-gradient(135deg, var(--accent), #60a5fa)
        }

        .dna {
            position: absolute;
            width: 34px;
            height: 72px;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) rotate(0deg);
            pointer-events: none;
        }

        .strand {
            position: absolute;
            width: 4px;
            height: 100%;
            left: 0;
            background: rgba(255, 255, 255, 0.14);
            border-radius: 2px
        }

        .strand.right {
            left: auto;
            right: 0;
            background: rgba(255, 255, 255, 0.18)
        }

        .base {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 28px;
            height: 4px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 2px
        }

        /* force arrows (visualize impulse magnitude) */
        .arrow {
            position: absolute;
            top: 44%;
            height: 14px;
            background: var(--accent);
            border-radius: 8px;
            opacity: 0;
            transform-origin: left center;
            will-change: transform, opacity;
        }

        .arrow.left {
            background: var(--accent2);
            transform-origin: right center;
        }

        /* control panel */
        #controls {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.03)
        }

        .row {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px
        }

        label {
            font-size: 13px;
            color: var(--muted);
            width: 90px
        }

        input[type=range] {
            flex: 1
        }

        input[type=number] {
            width: 90px;
            padding: 6px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            background: transparent;
            color: inherit
        }

        button {
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            background: transparent;
            color: inherit;
            cursor: pointer
        }

        .controls-row {
            display: flex;
            gap: 8px;
            margin-top: 8px
        }

        /* data panel */
        #data {
            margin-top: 6px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 6px;
            padding: 8px;
            font-size: 13px;
            color: var(--muted)
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            color: inherit
        }

        th,
        td {
            padding: 6px 8px;
            text-align: center
        }

        th {
            color: var(--muted);
            font-weight: 600;
            font-size: 12px
        }

        td.val {
            font-weight: 600;
            color: #e6eef8
        }

        footer {
            width: 95%;
            max-width: 1100px;
            margin-top: 12px;
            color: var(--muted);
            font-size: 13px
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.03);
            margin-right: 8px
        }
    </style>
</head>

<body>

    <header>
        <h1>Elastic Collision — Interactive Lab</h1>
        <p class="lead">Accurate, timestep-correct collision handling + visual force (impulse) arrows. Use controls to
            change masses/velocities, speed, and watch the live data & conservation checks.</p>
    </header>

    <div id="container">
        <div id="lab">
            <div id="arena">
                <div class="wall left"></div>
                <div class="wall right"></div>

                <div id="ball1" class="ball">
                    <div style="text-align:center">m=3</div>
                </div>
                <div id="ball2" class="ball">
                    <div style="text-align:center">m=1</div>
                </div>

                <div id="arrow1" class="arrow left"></div>
                <div id="arrow2" class="arrow"></div>
            </div>
        </div>

        <aside id="controls">
            <div class="row"><label>Mass 1</label><input id="m1" type="range" min="0.5" max="10" step="0.1"
                    value="3"><input id="m1n" type="number" step="0.1" value="3"></div>
            <div class="row"><label>Vel 1</label><input id="v1" type="range" min="-8" max="12" step="0.1"
                    value="3"><input id="v1n" type="number" step="0.1" value="3"></div>

            <div class="row"><label>Mass 2</label><input id="m2" type="range" min="0.2" max="10" step="0.1"
                    value="1"><input id="m2n" type="number" step="0.1" value="1"></div>
            <div class="row"><label>Vel 2</label><input id="v2" type="range" min="-12" max="8" step="0.1"
                    value="-2"><input id="v2n" type="number" step="0.1" value="-2"></div>

            <div class="row"><label>Time scale</label><input id="timeScale" type="range" min="0.1" max="4" step="0.1"
                    value="1"><input id="timeScalen" type="number" step="0.1" value="1"></div>

            <div class="controls-row">
                <button id="playPause">Pause</button>
                <button id="step">Step ⇥</button>
                <button id="reset">Reset</button>
                <button id="randomize">Randomize</button>
            </div>

            <div id="data" style="margin-top:10px">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                    <div><strong>Live Data</strong></div>
                    <div>
                        <span class="badge">Collisions: <span id="collCount">0</span></span>
                        <span class="badge">FPS: <span id="fps">--</span></span>
                    </div>
                </div>

                <table>
                    <thead>
                        <tr>
                            <th></th>
                            <th>Position</th>
                            <th>Velocity</th>
                            <th>Momentum</th>
                            <th>KE</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Ball 1</td>
                            <td class="val" id="pos1">--</td>
                            <td class="val" id="vel1">--</td>
                            <td class="val" id="mom1">--</td>
                            <td class="val" id="ke1">--</td>
                        </tr>
                        <tr>
                            <td>Ball 2</td>
                            <td class="val" id="pos2">--</td>
                            <td class="val" id="vel2">--</td>
                            <td class="val" id="mom2">--</td>
                            <td class="val" id="ke2">--</td>
                        </tr>
                        <tr style="border-top:1px dashed rgba(255,255,255,0.04)">
                            <td>Total</td>
                            <td class="val" id="posTot">—</td>
                            <td class="val" id="velTot">—</td>
                            <td class="val" id="momTot">—</td>
                            <td class="val" id="keTot">—</td>
                        </tr>
                    </tbody>
                </table>
                <div style="margin-top:8px;color:var(--muted);font-size:12px">
                    <strong>Conservation:</strong> momentum and kinetic energy shown as totals; small numeric
                    differences due to floating point are displayed.
                </div>
            </div>
        </aside>
    </div>

    <footer>
        Tip: this demo runs a high-precision simulation. If motion looks jumpy, increase Time scale or reduce
        velocities. 
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script>
        /*
          Physics-first elastic collision demo
          - Time-accurate (uses dt in seconds from performance.now())
          - Detects exact collision time in-frame to avoid tunneling
          - Resolves 1D elastic collisions (conservation of momentum + energy)
          - Visual impulse arrows sized by impulse magnitude using Anime.js for micro-animation
          - GPU-friendly transforms, will-change, and limited DOM updates
        */

        (() => {
            // DOM refs
            const arena = document.querySelector('#arena');
            const ball1El = document.querySelector('#ball1');
            const ball2El = document.querySelector('#ball2');
            const arrow1 = document.querySelector('#arrow1');
            const arrow2 = document.querySelector('#arrow2');

            // Controls
            const m1s = document.querySelector('#m1'), m1n = document.querySelector('#m1n');
            const m2s = document.querySelector('#m2'), m2n = document.querySelector('#m2n');
            const v1s = document.querySelector('#v1'), v1n = document.querySelector('#v1n');
            const v2s = document.querySelector('#v2'), v2n = document.querySelector('#v2n');
            const timeScaleS = document.querySelector('#timeScale'), timeScaleN = document.querySelector('#timeScalen');

            const playPauseBtn = document.querySelector('#playPause');
            const stepBtn = document.querySelector('#step');
            const resetBtn = document.querySelector('#reset');
            const randomBtn = document.querySelector('#randomize');

            // Data elements
            const pos1El = document.querySelector('#pos1'), pos2El = document.querySelector('#pos2');
            const vel1El = document.querySelector('#vel1'), vel2El = document.querySelector('#vel2');
            const mom1El = document.querySelector('#mom1'), mom2El = document.querySelector('#mom2');
            const ke1El = document.querySelector('#ke1'), ke2El = document.querySelector('#ke2');
            const momTotEl = document.querySelector('#momTot'), keTotEl = document.querySelector('#keTot');
            const collCountEl = document.querySelector('#collCount'), fpsEl = document.querySelector('#fps');

            // Simulation variables
            let width = arena.clientWidth;
            let height = arena.clientHeight;
            const radius = 40; // ball radius (px) - matches CSS 80px
            const leftBound = radius + 6; // account for wall width
            const rightBound = width - radius - 6;

            // state
            let state = {
                m1: parseFloat(m1s.value),
                m2: parseFloat(m2s.value),
                x1: leftBound, // center x in px
                x2: rightBound,
                v1: parseFloat(v1s.value), // px / frame? we'll treat as px/sec after dt calc
                v2: parseFloat(v2s.value),
                running: true,
                timeScale: parseFloat(timeScaleS.value),
                collisionCount: 0,
            };

            // FPS sampling
            let lastFrameTime = performance.now();
            let lastFpsTime = lastFrameTime;
            let frameCount = 0;

            // sync numeric inputs and sliders
            function bindRangeNumber(range, number, prop) {
                range.addEventListener('input', e => {
                    number.value = range.value;
                    state[prop] = parseFloat(range.value);
                    if (prop === 'm1' || prop === 'm2') updateMassLabels();
                });
                number.addEventListener('change', e => {
                    range.value = number.value;
                    state[prop] = parseFloat(number.value);
                    if (prop === 'm1' || prop === 'm2') updateMassLabels();
                });
            }
            bindRangeNumber(m1s, m1n, 'm1');
            bindRangeNumber(m2s, m2n, 'm2');
            bindRangeNumber(v1s, v1n, 'v1');
            bindRangeNumber(v2s, v2n, 'v2');
            bindRangeNumber(timeScaleS, timeScaleN, 'timeScale');

            function updateMassLabels() {
                ball1El.innerHTML = `<div style="text-align:center">m=${state.m1.toFixed(1)}</div>`;
                ball2El.innerHTML = `<div style="text-align:center">m=${state.m2.toFixed(1)}</div>`;
            }
            updateMassLabels();

            // Initialization / reset
            function reset(startFresh = true) {
                width = arena.clientWidth;
                state.x1 = leftBound;
                state.x2 = width - radius - 6;
                state.collisionCount = 0;
                collCountEl.textContent = state.collisionCount;
                // ensure velocities reflect controls
                state.v1 = parseFloat(v1s.value);
                state.v2 = parseFloat(v2s.value);
                updateElementsImmediate();
                // clear arrows
                arrow1.style.opacity = arrow2.style.opacity = 0;
                // reset counters/time
                lastFrameTime = performance.now();
                lastFpsTime = lastFrameTime;
                frameCount = 0;
                if (startFresh) state.running = true;
            }

            // update DOM transform directly (fast, minimal layout)
            function setBallTransform(el, x) {
                // anchor transform uses translateY(-50%) already in CSS; we only change translateX
                el.style.transform = `translateX(${x - radius}px) translateY(-50%)`;
            }

            function updateElementsImmediate() {
                setBallTransform(ball1El, state.x1);
                setBallTransform(ball2El, state.x2);
                // update data display
                pos1El.textContent = state.x1.toFixed(0);
                pos2El.textContent = state.x2.toFixed(0);
                vel1El.textContent = (state.v1).toFixed(2);
                vel2El.textContent = (state.v2).toFixed(2);
                mom1El.textContent = (state.m1 * state.v1).toFixed(2);
                mom2El.textContent = (state.m2 * state.v2).toFixed(2);
                ke1El.textContent = (0.5 * state.m1 * state.v1 * state.v1).toFixed(2);
                ke2El.textContent = (0.5 * state.m2 * state.v2 * state.v2).toFixed(2);
                const momTot = state.m1 * state.v1 + state.m2 * state.v2;
                const keTot = 0.5 * state.m1 * state.v1 * state.v1 + 0.5 * state.m2 * state.v2 * state.v2;
                momTotEl.textContent = momTot.toFixed(3);
                keTotEl.textContent = keTot.toFixed(3);
            }

            // precise collision solver for 1D elastic spheres
            // handles collision within dt: advances to collision time, resolves velocities, then continues for remaining dt
            function stepPhysics(dt) {
                // dt in seconds, but velocities are in px per second: use consistent units
                // We'll loop because multiple collisions/wall impacts may occur within one large dt
                let remaining = dt;
                const maxLoops = 6; // safety
                let loops = 0;

                while (remaining > 1e-6 && loops < maxLoops) {
                    loops++;
                    // time to collision between balls (if any)
                    const relV = state.v1 - state.v2;
                    const dist = state.x2 - state.x1 - 2 * radius; // gap between surfaces
                    let tCollide = Infinity;
                    if (relV > 0) { // v1 catching up to v2 (only then can collide)
                        tCollide = dist / relV; // may be negative or positive
                    }

                    // time to wall collisions
                    let tWall1 = Infinity, tWall2 = Infinity;
                    if (state.v1 < 0) tWall1 = (leftBound - state.x1) / state.v1;
                    else if (state.v1 > 0) tWall1 = (rightBound - state.x1) / state.v1;

                    if (state.v2 < 0) tWall2 = (leftBound - state.x2) / state.v2;
                    else if (state.v2 > 0) tWall2 = (rightBound - state.x2) / state.v2;

                    // pick earliest positive event within remaining
                    const candidates = [tCollide, tWall1, tWall2].map(t => (t >= 0 ? t : Infinity));
                    const tNext = Math.min(...candidates, remaining);

                    if (tNext > remaining - 1e-9) {
                        // No events in the remaining dt: advance everything
                        state.x1 += state.v1 * remaining;
                        state.x2 += state.v2 * remaining;
                        remaining = 0;
                    } else {
                        // Advance to the event time tNext
                        state.x1 += state.v1 * tNext;
                        state.x2 += state.v2 * tNext;
                        remaining -= tNext;

                        if (Math.abs(tNext - tCollide) < 1e-8) {
                            // Ball-ball collision: resolve elastic
                            const u1 = state.v1, u2 = state.v2, m1 = state.m1, m2 = state.m2;
                            const v1p = ((m1 - m2) / (m1 + m2)) * u1 + (2 * m2 / (m1 + m2)) * u2;
                            const v2p = (2 * m1 / (m1 + m2)) * u1 + ((m2 - m1) / (m1 + m2)) * u2;
                            // compute impulse magnitude J = m1*(v1p - u1) (absolute)
                            const impulse = Math.abs(m1 * (v1p - u1));
                            // update velocities
                            state.v1 = v1p;
                            state.v2 = v2p;
                            state.collisionCount++;
                            collCountEl.textContent = state.collisionCount;
                            // show force arrows (impulse visualization)
                            showImpulse(impulse);
                            // tiny positional correction to avoid sticking
                            const overlap = (state.x1 + 2 * radius) - state.x2;
                            if (overlap > 0) {
                                // push them apart along new velocities
                                const push = overlap / 2 + 0.5;
                                state.x1 -= push;
                                state.x2 += push;
                            }
                        } else if (Math.abs(tNext - tWall1) < 1e-8) {
                            // ball1 hits wall — reflect velocity
                            state.v1 *= -1;
                            // small nudge
                            if (state.x1 < leftBound) state.x1 = leftBound;
                            if (state.x1 > rightBound) state.x1 = rightBound;
                            showWallImpact(1);
                        } else if (Math.abs(tNext - tWall2) < 1e-8) {
                            state.v2 *= -1;
                            if (state.x2 < leftBound) state.x2 = leftBound;
                            if (state.x2 > rightBound) state.x2 = rightBound;
                            showWallImpact(2);
                        } else {
                            // fallback: consume remaining
                            state.x1 += state.v1 * remaining;
                            state.x2 += state.v2 * remaining;
                            remaining = 0;
                        }
                    }
                }
                // end loop
            }

            // visual impulse: scales arrow length and animates opacity using Anime.js
            function showImpulse(impulse) {
                // scale impulse to a reasonable pixel width range
                const maxVisual = 180;
                const scale = Math.min(maxVisual, impulse * 10 + 30); // tweak multiplier for visibility
                const center = arena.clientWidth / 2;
                // place arrows near center
                arrow1.style.left = (center - 80) + 'px';
                arrow1.style.width = scale + 'px';
                arrow2.style.left = (center + 10) + 'px';
                arrow2.style.width = scale + 'px';
                // animate
                anime.remove([arrow1, arrow2]);
                anime({
                    targets: [arrow1, arrow2],
                    opacity: [0, 1],
                    translateX: (el, i) => i === 0 ? -10 : 10,
                    duration: 260,
                    easing: 'easeOutQuad',
                    complete: () => {
                        anime({
                            targets: [arrow1, arrow2],
                            opacity: [1, 0],
                            duration: 400,
                            delay: 120,
                            easing: 'easeInQuad'
                        });
                    }
                });
            }

            function showWallImpact(ballIndex) {
                const el = (ballIndex === 1) ? ball1El : ball2El;
                anime({
                    targets: el,
                    scale: [1, 1.08, 1],
                    duration: 250,
                    easing: 'easeOutElastic(1, .6)'
                });
            }

            // main loop
            function loop(now) {
                const rawDtMs = now - lastFrameTime;
                lastFrameTime = now;
                if (!state.running) {
                    // still update fps counters for UI responsiveness
                    tickFps(rawDtMs);
                    requestAnimationFrame(loop);
                    return;
                }

                // dt in seconds, adjusted by timeScale
                const dt = (rawDtMs / 1000) * state.timeScale;
                // cap dt to avoid instabilities during large tab switching
                const dtUse = Math.min(0.033, dt);

                // physics step
                stepPhysics(dtUse);

                // render (fast): transforms
                setBallTransform(ball1El, state.x1);
                setBallTransform(ball2El, state.x2);

                // update data UI (debounced? small cost — fine)
                pos1El.textContent = state.x1.toFixed(0);
                pos2El.textContent = state.x2.toFixed(0);
                vel1El.textContent = state.v1.toFixed(2);
                vel2El.textContent = state.v2.toFixed(2);
                mom1El.textContent = (state.m1 * state.v1).toFixed(3);
                mom2El.textContent = (state.m2 * state.v2).toFixed(3);
                ke1El.textContent = (0.5 * state.m1 * state.v1 * state.v1).toFixed(3);
                ke2El.textContent = (0.5 * state.m2 * state.v2 * state.v2).toFixed(3);

                const momTot = state.m1 * state.v1 + state.m2 * state.v2;
                const keTot = 0.5 * state.m1 * state.v1 * state.v1 + 0.5 * state.m2 * state.v2 * state.v2;
                momTotEl.textContent = momTot.toFixed(6);
                keTotEl.textContent = keTot.toFixed(6);

                tickFps(rawDtMs);

                requestAnimationFrame(loop);
            }

            // FPS helper
            function tickFps(dtMs) {
                frameCount++;
                const now = performance.now();
                if (now - lastFpsTime >= 500) {
                    const fps = Math.round((frameCount * 1000) / (now - lastFpsTime));
                    fpsEl.textContent = fps;
                    frameCount = 0;
                    lastFpsTime = now;
                }
            }

            // controls
            playPauseBtn.addEventListener('click', () => {
                state.running = !state.running;
                playPauseBtn.textContent = state.running ? 'Pause' : 'Play';
            });

            stepBtn.addEventListener('click', () => {
                // advance a single small step (~16ms)
                stepPhysics(0.016 * state.timeScale);
                updateElementsImmediate();
            });

            resetBtn.addEventListener('click', () => reset(true));
            randomBtn.addEventListener('click', () => {
                // randomize masses and velocities sensibly
                const m1v = +(Math.random() * 8 + 0.5).toFixed(2);
                const m2v = +(Math.random() * 8 + 0.2).toFixed(2);
                const v1v = +(Math.random() * 10 - 3).toFixed(2);
                const v2v = +(Math.random() * -10 + 3).toFixed(2);
                m1s.value = m1n.value = m1v; state.m1 = m1v;
                m2s.value = m2n.value = m2v; state.m2 = m2v;
                v1s.value = v1n.value = v1v; state.v1 = v1v;
                v2s.value = v2n.value = v2v; state.v2 = v2v;
                updateMassLabels();
                reset(true);
            });

            // handle resize
            window.addEventListener('resize', () => {
                width = arena.clientWidth;
                // adjust bounds and clamp positions
                const newRight = width - radius - 6;
                if (state.x2 > newRight) state.x2 = newRight;
                lastFrameTime = performance.now();
            });

            // init visuals & start
            reset();
            requestAnimationFrame(loop);
        })();
    </script>
</body>

</html>